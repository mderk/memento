#!/usr/bin/env python3
"""
Validate Memory Bank links and file integrity.

Checks:
1. All files from generation-plan.md exist
2. All markdown links in index.md files are valid
3. Cross-references between files are valid
"""

import re
import sys
from pathlib import Path
from typing import List, Tuple


def read_generation_plan(plan_path: Path) -> List[Tuple[str, bool]]:
    """
    Parse generation-plan.md and extract files with their completion status.

    Returns: List of (file_path, is_completed) tuples
    """
    if not plan_path.exists():
        print(f"‚ùå Generation plan not found: {plan_path}")
        return []

    files = []
    try:
        content = plan_path.read_text(encoding='utf-8')
    except UnicodeDecodeError as e:
        print(f"‚ùå ENCODING ERROR in generation plan: {plan_path}")
        print(f"   Error: {e}")
        print(f"   Generation plan must be valid UTF-8.")
        sys.exit(1)

    # Match lines like: - [x] filename (target: path/to/file.md)
    # or: - [ ] filename (target: path/to/file.md)
    pattern = r'- \[([ x])\] .+? \(target: (.+?)\)'

    for match in re.finditer(pattern, content):
        is_completed = match.group(1) == 'x'
        file_path = match.group(2).strip()
        files.append((file_path, is_completed))

    return files


def check_file_existence(base_dir: Path, files: List[Tuple[str, bool]]) -> Tuple[int, int, List[str]]:
    """
    Check if all completed files exist.

    Returns: (total_files, existing_files, missing_files)
    """
    completed = [(path, completed) for path, completed in files if completed]
    missing = []

    for file_path, _ in completed:
        full_path = base_dir / file_path
        if not full_path.exists():
            missing.append(file_path)

    return len(completed), len(completed) - len(missing), missing


def find_markdown_links(file_path: Path) -> List[Tuple[str, str]]:
    """
    Extract all markdown links from a file.

    Returns: List of (link_text, link_target) tuples
    """
    if not file_path.exists():
        return []

    try:
        content = file_path.read_text(encoding='utf-8')
    except UnicodeDecodeError as e:
        # Memory Bank files MUST be valid UTF-8 (generated by LLM)
        # If encoding error found - this indicates corruption or manual edit with wrong encoding
        rel_path = file_path.relative_to(Path.cwd()) if file_path.is_relative_to(Path.cwd()) else file_path
        print(f"\n‚ùå ENCODING ERROR: {rel_path}")
        print(f"   Error: {e}")
        print(f"   Memory Bank files must be valid UTF-8.")
        print(f"   This file was likely edited manually with wrong encoding (Windows-1252?).")
        print(f"   Fix: Re-save file as UTF-8 or regenerate from prompt.\n")
        sys.exit(1)

    # Match markdown links: [text](target)
    pattern = r'\[([^\]]+)\]\(([^)]+)\)'
    links = []

    for match in re.finditer(pattern, content):
        link_text = match.group(1)
        link_target = match.group(2)

        # Skip external links (http://, https://, mailto:)
        if not link_target.startswith(('http://', 'https://', 'mailto:', '#')):
            links.append((link_text, link_target))

    return links


def resolve_link(source_file: Path, link_target: str) -> Path:
    """
    Resolve a relative link from source_file to absolute path.

    Handles:
    - Relative paths: ./file.md, ../file.md
    - Absolute paths from repo root: /.memory_bank/file.md
    """
    # Remove anchor fragments
    if '#' in link_target:
        link_target = link_target.split('#')[0]

    if not link_target:  # Pure anchor link
        return source_file

    # If starts with /, it's from repo root
    if link_target.startswith('/'):
        return source_file.parent.parent.parent / link_target.lstrip('/')

    # Otherwise resolve relative to source file
    return (source_file.parent / link_target).resolve()


def validate_index_links(base_dir: Path) -> Tuple[int, int, List[str]]:
    """
    Find all index.md files and validate their links.

    Returns: (total_links, valid_links, broken_links_with_details)
    """
    index_files = list(base_dir.rglob('index.md'))

    total_links = 0
    valid_links = 0
    broken = []

    for index_file in index_files:
        links = find_markdown_links(index_file)

        for link_text, link_target in links:
            total_links += 1
            resolved = resolve_link(index_file, link_target)

            if resolved.exists():
                valid_links += 1
            else:
                rel_source = index_file.relative_to(base_dir)
                broken.append(f"{rel_source}: [{link_text}]({link_target}) ‚Üí {resolved.relative_to(base_dir)}")

    return total_links, valid_links, broken


def validate_cross_references(base_dir: Path) -> Tuple[int, int, List[str], List[str]]:
    """
    Check all markdown links in all .md files (cross-references).

    Returns: (total_refs, valid_refs, broken_refs, placeholder_refs)
    """
    # Exclude common third-party and build directories
    excluded_dirs = {'node_modules', '.git', 'venv', '__pycache__', '.backup',
                     'dist', 'build', '.venv', 'env', '.pytest_cache'}

    md_files = []
    for f in base_dir.rglob('*.md'):
        # Check if any part of the path is in excluded directories
        if not any(part in excluded_dirs for part in f.parts):
            md_files.append(f)

    total_refs = 0
    valid_refs = 0
    broken = []
    placeholders = []

    for md_file in md_files:
        links = find_markdown_links(md_file)

        for link_text, link_target in links:
            total_refs += 1

            # Check for placeholder links (internal, TBD, TODO, etc.)
            if link_target in ('internal', 'TBD', 'TODO', 'tbd', 'todo'):
                placeholders.append(f"{md_file.relative_to(base_dir)}: [{link_text}]({link_target})")
                continue

            resolved = resolve_link(md_file, link_target)

            if resolved.exists():
                valid_refs += 1
            else:
                rel_source = md_file.relative_to(base_dir)
                broken.append(f"{rel_source}: [{link_text}]({link_target}) ‚Üí {resolved.relative_to(base_dir)}")

    return total_refs, valid_refs, broken, placeholders


def main():
    """Main validation function."""
    # Determine base directory (where script is run from)
    base_dir = Path.cwd()

    # Check if we're in a project with .memory-bank/generation-plan.md
    plan_path = base_dir / '.memory-bank' / 'generation-plan.md'

    if not plan_path.exists():
        print(f"‚ùå No generation plan found at: {plan_path}")
        print(f"   Current directory: {base_dir}")
        print(f"   Run this script from project root after /create-environment")
        sys.exit(1)

    print(f"üîç Validating Memory Bank integrity...\n")
    print(f"   Working directory: {base_dir}")
    print(f"   Generation plan: {plan_path}\n")

    # Step 1: Check file existence
    print("1Ô∏è‚É£  Checking file existence...")
    files = read_generation_plan(plan_path)
    total_files, existing_files, missing_files = check_file_existence(base_dir, files)

    if missing_files:
        print(f"‚ùå {len(missing_files)} files missing:")
        for f in missing_files[:5]:  # Show first 5
            print(f"   - {f}")
        if len(missing_files) > 5:
            print(f"   ... and {len(missing_files) - 5} more")
    else:
        print(f"‚úÖ All {existing_files} files exist")

    # Step 2: Validate index links
    print("\n2Ô∏è‚É£  Validating index.md links...")
    total_idx_links, valid_idx_links, broken_idx = validate_index_links(base_dir)

    if broken_idx:
        print(f"‚ùå {len(broken_idx)} broken index links:")
        for link in broken_idx[:5]:
            print(f"   - {link}")
        if len(broken_idx) > 5:
            print(f"   ... and {len(broken_idx) - 5} more")
    else:
        print(f"‚úÖ All {valid_idx_links} index links valid")

    # Step 3: Validate cross-references
    print("\n3Ô∏è‚É£  Validating cross-references...")
    total_refs, valid_refs, broken_refs, placeholders = validate_cross_references(base_dir)

    if broken_refs:
        print(f"‚ö†Ô∏è  {len(broken_refs)} broken cross-references:")
        for ref in broken_refs[:5]:
            print(f"   - {ref}")
        if len(broken_refs) > 5:
            print(f"   ... and {len(broken_refs) - 5} more")
    else:
        print(f"‚úÖ All {valid_refs} cross-references valid")

    # Show placeholders separately (info only)
    if placeholders:
        print(f"\n‚ÑπÔ∏è  {len(placeholders)} placeholder links (intentional):")
        for ref in placeholders[:3]:
            print(f"   - {ref}")
        if len(placeholders) > 3:
            print(f"   ... and {len(placeholders) - 3} more")

    # Summary
    print("\n" + "=" * 60)
    print("üìä VALIDATION SUMMARY")
    print("=" * 60)
    print(f"Files:            {existing_files}/{total_files} exist")
    print(f"Index links:      {valid_idx_links}/{total_idx_links} valid")
    print(f"Cross-references: {valid_refs}/{total_refs} valid")
    if placeholders:
        print(f"Placeholders:     {len(placeholders)} intentional")

    # Exit code - NO broken links allowed (strict mode)
    has_errors = len(missing_files) > 0 or len(broken_idx) > 0 or len(broken_refs) > 0

    if has_errors:
        print("\n‚ùå Validation FAILED")
        if len(missing_files) > 0:
            print(f"   - {len(missing_files)} files missing from generation plan")
        if len(broken_idx) > 0:
            print(f"   - {len(broken_idx)} broken index.md links")
        if len(broken_refs) > 0:
            print(f"   - {len(broken_refs)} broken cross-references")
        print("\n‚ö†Ô∏è  RULE: NO broken links allowed. Either fix or remove them.")
        print("   Broken links are usually LLM hallucinations of non-existent files.")
        sys.exit(1)
    else:
        print("\n‚úÖ All validation checks passed!")
        sys.exit(0)


if __name__ == '__main__':
    main()
